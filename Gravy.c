#pragma config(Sensor, in6,    SwingPot,       sensorPotentiometer)
#pragma config(Sensor, in7,    GyroSensor,     sensorGyro)
#pragma config(Sensor, in8,    MogoPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightEnc,       sensorQuadEncoder)
#pragma config(Motor,  port2,           LeftFrontDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RightFrontDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LeftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Roller,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           Mogo,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftRearDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightRearDrive, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//PROTOTYPES
void autoStack();
void drivePID(int driveDistance);
void driveP(int driveDistance);
void driveReverseP(int driveDistance);
void turnLeft(int driveDistance);
void turnRight(int driveDistance);
void displayAuton();


//GLOBALS
int auton;
int numAutons = 4;
int numCones = 5;
int startVal = 0;

task mogoDown()
{
	motor[Mogo] = 0;
	wait1Msec(20);
	while(SensorValue[MogoPot] < 3500)
	{
		motor[Mogo] = -127;
		wait1Msec(20);
		hogCPU(); //??
	}
	releaseCPU();
	motor[Mogo] = -20;
	wait1Msec(20);
	stopTask(mogoDown);
}

task mogoUp()
{
	motor[Mogo] = 0;
	wait1Msec(20);

	while(SensorValue[MogoPot] > 880)
	{
		motor[Mogo] = 127;
		wait1Msec(20);
	}
	motor[Mogo] = 0;
	wait1Msec(20);
	stopTask(mogoUp);
}

task LCDControl()
{
	clearLCDLine(0);
	clearLCDLine(1);
	bool noButtonsPressed = true;
	displayAuton();
	while(true){
		if(noButtonsPressed){ // only update auton if a button is pressed AND wasn't pressed previously
			switch(nLCDButtons){
			case kButtonLeft:
				auton--;
				if (auton < 0)
					auton = 0;
				displayAuton();
				break;
			case kButtonCenter:
				stopTask(LCDControl);
				break;
			case kButtonRight:
				auton++;
				if(auton > numAutons)
					auton = numAutons;
				displayAuton();
				break;
			}
		}
		noButtonsPressed = !nLCDButtons; //update if there is a button currently pressed
		wait1Msec(20);
	}
}

void displayAuton()
{
	switch(auton)
	{
	case 0:
		displayLCDCenteredString(0, "Red Mogo");
		break;

	case 1:
		displayLCDCenteredString(0, "Red Post");
		break;

	case 2:
		displayLCDCenteredString(0, "Blue Mogo");
		break;

	case 3:
		displayLCDCenteredString(0, "Blue Post");
		break;

	default:
		displayLCDCenteredString(0, "No auton");
		break;
	}
}

void pre_auton()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in7] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in7] = sensorGyro;
	wait1Msec(2000);
	bLCDBacklight = true;

	clearLCDLine(0);
	clearLCDLine(1);
	bDisplayCompetitionStatusOnLcd = false;
	startTask(LCDControl);

	bStopTasksBetweenModes = true;
}

task autonomous()
{
	clearLCDLine(0);
	clearLCDLine(1);
	stopTask(LCDControl);
	switch(auton){
	case 1:
		motor[LeftLift] = -30;
		motor[RightLift] = -30;
		//drop onto stationary goal
		driveReverseP(230);
		motor[LeftLift] = 10;
		motor[RightLift] = 10;
		wait1Msec(200);
		driveP(157);

		motor[RightLift] = 0;
		motor[LeftLift] = 0;

		//go to the left mobile goal
		// turn right
		turnRight(480);

		//drive forward to near loader wall
		driveP(600);

		//turn right to face first mogo
		turnRight(333);

		//mogo out
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//drive forward
		driveP(1150);

		motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
		//mogo in
		motor[Mogo] = 127;
		wait1Msec(1200);
		motor[Mogo] = 0;

		//drive back
		driveReverseP(275);

		//turn right
		turnRight(505);

		//back up
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
		wait1Msec(1500);

		//autostack onto left mobile goal
		autoStack();

		//place left mobile goal on far scoring goal
		//go straight
		driveP(325);

		//turn right
		turnRight(720);

		//drive straight
		driveP(791);

		//mogo down
		//stopTask(mogoUp);
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//dive backwards
		driveReverseP(342);

		break;

	case 0:
	motor[Roller] = 30;
	startVal = 0;
	numCones = 1;

		//mogo out
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//drive forward
		driveP(1300);

		motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
		//mogo in
		wait1Msec(500);
		motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		//mogo in
		wait1Msec(20);

		motor[Mogo] = 127;
		wait1Msec(1200);
		motor[Mogo] = 0;
		autoStack();
		motor[LeftLift] =0;
		motor[RightLift] = 0;

		//drive back
		driveReverseP(250);

		//turn right
		turnRight(535);

		//back up
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
		wait1Msec(1500);

				motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		wait1Msec(10);

				motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
		wait1Msec(50);

				motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		wait1Msec(10);

		//autostack onto left mobile goal
		numCones = 4;
		startVal = 1;
		autoStack();

		//place left mobile goal on far scoring goal
		//go straight
		driveP(325);

		//turn right
		turnRight(680);

		//drive straight
		driveP(850);

		//turn right
		turnRight(100);

		motor[LeftFrontDrive] = 30;
		motor[LeftRearDrive] = 30;
		motor[RightFrontDrive] = 30;
		motor[RightRearDrive] = 30;
		wait1Msec(1000);

				motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		wait1Msec(10);

		//mogo down
		//stopTask(mogoUp);
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//dive backwards
		driveReverseP(342);
		break;

	case 2:
		motor[Roller] = 30;
	startVal = 0;
	numCones = 1;

		//mogo out
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//drive forward
		driveP(1300);

		motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
		//mogo in
		wait1Msec(500);
		motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		//mogo in
		wait1Msec(20);

		motor[Mogo] = 127;
		wait1Msec(1200);
		motor[Mogo] = 0;
		autoStack();
		motor[LeftLift] =0;
		motor[RightLift] = 0;

		//drive back
		driveReverseP(230);

		//turn right
		turnLeft(400);

		//back up
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
		wait1Msec(1500);

				motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		wait1Msec(10);

				motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
		wait1Msec(50);

				motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		wait1Msec(10);

		//autostack onto left mobile goal
		numCones = 4;
		startVal = 1;
		autoStack();

		//place left mobile goal on far scoring goal
		//go straight
		driveP(325);

		//turn right
		turnLeft(400);

		//drive straight
		driveP(850);

		//turn right
		turnLeft(200);

		motor[LeftFrontDrive] = 30;
		motor[LeftRearDrive] = 30;
		motor[RightFrontDrive] = 30;
		motor[RightRearDrive] = 30;
		wait1Msec(1000);

				motor[LeftFrontDrive] = 0;
		motor[LeftRearDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[RightRearDrive] = 0;
		wait1Msec(10);

		//mogo down
		//stopTask(mogoUp);
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//dive backwards
		driveReverseP(342);
	break;

	case 3:
			motor[LeftLift] = -30;
		motor[RightLift] = -30;
		//drop onto stationary goal
		driveReverseP(230);
		motor[LeftLift] = 10;
		motor[RightLift] = 10;
		wait1Msec(200);
		driveP(157);

		motor[RightLift] = 0;
		motor[LeftLift] = 0;

		//go to the left mobile goal
		// turn right
		turnLeft(480);

		//drive forward to near loader wall
		driveP(600);

		//turn right to face first mogo
		turnLeft(333);

		//mogo out
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//drive forward
		driveP(1150);

		motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
		//mogo in
		motor[Mogo] = 127;
		wait1Msec(1200);
		motor[Mogo] = 0;

		//drive back
		driveReverseP(275);

		//turn right
		turnLeft(420);

		//back up
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
		wait1Msec(1500);

		//autostack onto left mobile goal
		autoStack();

		//place left mobile goal on far scoring goal
		//go straight
		driveP(325);

		//turn right
		turnLeft(720);

		//drive straight
		driveP(791);

		//mogo down
		//stopTask(mogoUp);
		motor[Mogo] = -127;
		wait1Msec(1200);
		motor[Mogo] = -20;

		//dive backwards
		driveReverseP(342);

		break;

	default:

		break;
	}

}

void autoStack()
{
	int grabHeight = 3950;
	int armDrop[5] = {250, 550, 650, 1000, 1300};


	//hug wall while stacking to preventing rocking
	/*
	motor[LeftFrontDrive] = -10;
	motor[LeftRearDrive] = -10;
	motor[RightFrontDrive] = -10;
	motor[RightRearDrive] = -10;
	*/

	for(int i = 0; i < numCones; i++)
	{
		/*
		while(SensorValue[SwingPot] < 2000 && vexRT[Btn6D] != 1)
		{
		motor[Roller] = -127;
		motor[LeftLift] = 127;
		motor[RightLift] = 127;
		wait1Msec(20);
		}
		*/

		//drop Roller down to grab height to grab cone
		while(SensorValue[SwingPot] < grabHeight && vexRT[Btn6D] != 1)
		{
			motor[Roller] = 127;
			motor[LeftLift] = 127;
			motor[RightLift] = 127;
			wait1Msec(20);
		}
		wait1Msec(100);
		//Roller back over to arm drop height
		//slow down roller at certain height to 60
		while(SensorValue[SwingPot] > armDrop[i] && vexRT[Btn6D] != 1)
		{

			//right side determines drop height
			if(SensorValue[SwingPot] > armDrop[i] + 500)
			{
				motor[Roller] = 30;
				motor[LeftLift] = -127;
				motor[RightLift] = -127;
				wait1Msec(20);
			}
			else
			{
				//release cone
				motor[Roller] = -127;
			}
		}
		wait1Msec(100);

		//kill switch
		if(vexRT[Btn6D] == 1)
		{
			i = 6;
		}
	}
}


void turnRight(int driveDistance)
{
	int error = 0;
	int speed = 0;
	SensorValue[GyroSensor] = 0;
	wait1Msec(500); //??
	clearTimer(T2);
	clearTimer(T3);

	//while turn hasn't finished and time hasn't expired
	while(abs(SensorValue[GyroSensor]) < driveDistance && time1[T2] < 2000)
	{
		//find how far away from goal you are
		error = driveDistance + SensorValue[GyroSensor];

		//slow down according to how close the turn is to finishing
		if(error > 350)
		{
			speed = error/2;
			if(speed > 500)
			{
				speed = 500;
			}
			motor[LeftFrontDrive] = speed / 3;
			motor[LeftRearDrive] = speed / 3;
			motor[RightFrontDrive] = -speed / 3;
			motor[RightRearDrive] = -speed / 3;
		}
		else if(abs(error) < 200)
		{
			motor[LeftFrontDrive] = 20;
			motor[LeftRearDrive] = 20;
			motor[RightFrontDrive] = -20;
			motor[RightRearDrive] = -20;
		}
		else
		{
			motor[LeftFrontDrive] = 40;
			motor[LeftRearDrive] = 40;
			motor[RightFrontDrive] = -40;
			motor[RightRearDrive] = -40;
		}
	}


	//porportional brake based on how far you plan to move
	if(driveDistance > 1000)
	{
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = 30;
		motor[RightRearDrive] = 30;
	}
	else if(driveDistance > 600)
	{
		motor[LeftFrontDrive] = -25;
		motor[LeftRearDrive] = -25;
		motor[RightFrontDrive] = 25;
		motor[RightRearDrive] = 25;
	}
	else if (driveDistance < 300)
	{
		motor[LeftFrontDrive] = -15;
		motor[LeftRearDrive] = -15;
		motor[RightFrontDrive] = 15;
		motor[RightRearDrive] = 15;
	}
	else
	{
		motor[LeftFrontDrive] = -20;
		motor[LeftRearDrive] = -20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
	}
	wait1Msec(150);
	motor[LeftFrontDrive] = 0;
	motor[LeftRearDrive] = 0;
	motor[RightFrontDrive] = 0;
	motor[RightRearDrive] = 0;
}


void turnLeft(int driveDistance)

{
	int error = 0;
	float kG = .5;
	SensorValue[GyroSensor] = 0;
	wait1Msec(500);
	clearTimer(T2);
	clearTimer(T3);

	while(abs(SensorValue[GyroSensor]) < driveDistance && time1[T2] < 2000)
	{
		error = driveDistance - SensorValue[GyroSensor];
		motor[LeftFrontDrive] = -error * kG;
		motor[LeftRearDrive] = -error * kG;
		motor[RightFrontDrive] = error * kG;
		motor[RightRearDrive] = error * kG;
		wait1Msec(20);

	}

	if(driveDistance > 1000)
	{
		motor[LeftFrontDrive] = 30;
		motor[LeftRearDrive] = 30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
	}
	else if(driveDistance > 600)
	{
		motor[LeftFrontDrive] = 25;
		motor[LeftRearDrive] = 25;
		motor[RightFrontDrive] = -25;
		motor[RightRearDrive] = -25;
	}
	else if (driveDistance < 300)
	{
		motor[LeftFrontDrive] = 15;
		motor[LeftRearDrive] = 15;
		motor[RightFrontDrive] = -15;
		motor[RightRearDrive] = -15;
	}
	else
	{
		motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = -20;
		motor[RightRearDrive] = -20;
	}
	wait1Msec(150);

	motor[LeftFrontDrive] = 0;
	motor[LeftRearDrive] = 0;
	motor[RightFrontDrive] = 0;
	motor[RightRearDrive] = 0;

	wait1Msec(200);
}

void drivePID(int driveDistance)
{
	int maxDriveTime = 2000;
	int errorRight = 0;
	int prevErrorRight = 0;
	int integralRight = 0;
	int derivativeRight = 0;
	int speedRight;


	//PID constants
	float kP = .9;
	float kI = .00001;
	float kD = .005;
	float kG = 1.5;

	//reset all values
	SensorValue[LeftEnc] = 0;
	SensorValue[RightEnc] = 0;
	SensorValue[GyroSensor] = 0;
	wait1Msec(500);
	clearTimer(T1);
	clearTimer(T3);

	errorRight = driveDistance - SensorValue[RightEnc];
	prevErrorRight = driveDistance - SensorValue[RightEnc];

	while ( abs(SensorValue[RightEnc]) < driveDistance && time1(T1) < maxDriveTime)
	{
		errorRight = driveDistance - SensorValue[RightEnc];
		integralRight = integralRight + errorRight;
		if (errorRight == 0)
		{
			integralRight = 0;
		}
		derivativeRight = errorRight - prevErrorRight;
		prevErrorRight = errorRight;

		speedRight = errorRight*kP + integralRight*kI + derivativeRight*kD;

		speedRight = speedRight /10;


		if(abs(speedRight) < 30 && speedRight < 0)
		{
			speedRight = -30;
		}
		else if(abs(speedRight) < 30 && speedRight > 0)
		{
			speedRight = 30;
		}

		if(abs(SensorValue[RightEnc]) < 200)
		{
			if(driveDistance < 0)
			{
				speedRight= -126;
			}
			else
			{
				speedRight = 126;
			}
		}

		if(abs(SensorValue[RightEnc]) < errorRight / 4.0)
		{
			if(driveDistance < 0)
			{
				speedRight= -50;
			}
			else
			{
				speedRight = 50;
			}
		}


		motor[LeftFrontDrive] = speedRight + SensorValue[GyroSensor] * kG;
		motor[LeftRearDrive] = speedRight + SensorValue[GyroSensor] * kG;
		motor[RightFrontDrive] = speedRight - SensorValue[GyroSensor] * kG;
		motor[RightRearDrive] = speedRight - SensorValue[GyroSensor] * kG;

		wait1Msec(15);
	}
	//perform a brake porportional to how
	//fast the brake is expected to go
	if(driveDistance > 600)
	{
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
	}
	else if(driveDistance > 400)
	{
		motor[LeftFrontDrive] = -25;
		motor[LeftRearDrive] = -25;
		motor[RightFrontDrive] = -25;
		motor[RightRearDrive] = -25;
	}
	else if (driveDistance < 200)
	{
		motor[LeftFrontDrive] = -15;
		motor[LeftRearDrive] = -15;
		motor[RightFrontDrive] = -15;
		motor[RightRearDrive] = -15;
	}
	else
	{
		motor[LeftFrontDrive] = -20;
		motor[LeftRearDrive] = -20;
		motor[RightFrontDrive] = -20;
		motor[RightRearDrive] = -20;
	}
	wait1Msec(200);

	//kill motors
	motor[LeftFrontDrive] = 0;
	motor[RightFrontDrive] = 0;
	motor[LeftRearDrive] = 0;
	motor[RightRearDrive] = 0;
	wait1Msec(500);
	return;
}

void driveP(int driveDistance)
{
	int speed = 0;
	int error = 0;
	float kS = .3;
	float kG = .1;
	SensorValue[GyroSensor] = 0;
	SensorValue[LeftEnc] = 0;
	wait1Msec(500);
	clearTimer(T2);

	error = driveDistance - SensorValue[LeftEnc];
	while(error > 0 && time1[T2] < 4000)
	{
		error = driveDistance - SensorValue[LeftEnc];
		if(SensorValue[LeftEnc] < driveDistance/ 6)
		{
			speed = 150;
		}
		else if(error < driveDistance / 3 * 2)
		{
			speed = 100;
		}
		else
		{
			speed = error;
		}
		motor[LeftFrontDrive] = speed * kS + SensorValue[GyroSensor] * kG;
		motor[LeftRearDrive] = speed * kS + SensorValue[GyroSensor] * kG;
		motor[RightFrontDrive] = speed * kS - SensorValue[GyroSensor] * kG;
		motor[RightRearDrive] = speed * kS - SensorValue[GyroSensor] * kG;
	}

	if(driveDistance > 1000)
	{
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
	}
	else if(driveDistance > 600)
	{
		motor[LeftFrontDrive] = -30;
		motor[LeftRearDrive] = -30;
		motor[RightFrontDrive] = -30;
		motor[RightRearDrive] = -30;
	}
	else if (driveDistance < 300)
	{
		motor[LeftFrontDrive] = -25;
		motor[LeftRearDrive] = -25;
		motor[RightFrontDrive] = -25;
		motor[RightRearDrive] = -25;
	}
	else
	{
		motor[LeftFrontDrive] = -25;
		motor[LeftRearDrive] = -25;
		motor[RightFrontDrive] = -25;
		motor[RightRearDrive] = -25;
	}
	wait1Msec(200);

	motor[LeftFrontDrive] = 0;
	motor[LeftRearDrive] = 0;
	motor[RightFrontDrive] = 0;
	motor[RightRearDrive] = 0;

	wait1Msec(200);
}

void driveReverseP(int driveDistance)
{
	int speed = 0;
	int error = 0;
	float kS = .3;
	float kG = .5;
	SensorValue[GyroSensor] = 0;
	SensorValue[LeftEnc] = 0;
	wait1Msec(500);
	clearTimer(T2);

	error = driveDistance + SensorValue[LeftEnc];
	while(error > 0 && time1[T2] < 4000)
	{
		error = driveDistance + SensorValue[LeftEnc];
		//if in the first fraction
		if(abs(SensorValue[LeftEnc]) < driveDistance/ 6)
		{
			speed = -150;
		}
		//else in the last fraction of drive
		else if(error < driveDistance / 3 * 2)
		{
			speed = -75;
		}
		else
		{
			speed = -error;
		}
		motor[LeftFrontDrive] = speed * kS + SensorValue[GyroSensor] * kG;
		motor[LeftRearDrive] = speed * kS + SensorValue[GyroSensor] * kG;
		motor[RightFrontDrive] = speed * kS - SensorValue[GyroSensor] * kG;
		motor[RightRearDrive] = speed * kS - SensorValue[GyroSensor] * kG;
	}

	if(driveDistance > 1000)
	{
		motor[LeftFrontDrive] = 20;
		motor[LeftRearDrive] = 20;
		motor[RightFrontDrive] = 20;
		motor[RightRearDrive] = 20;
	}
	else if(driveDistance > 600)
	{
		motor[LeftFrontDrive] = 30;
		motor[LeftRearDrive] = 30;
		motor[RightFrontDrive] = 30;
		motor[RightRearDrive] = 30;
	}
	else if (driveDistance < 300)
	{
		motor[LeftFrontDrive] = 10;
		motor[LeftRearDrive] = 10;
		motor[RightFrontDrive] = 10;
		motor[RightRearDrive] = 10;
	}
	else
	{
		motor[LeftFrontDrive] = 12;
		motor[LeftRearDrive] = 12;
		motor[RightFrontDrive] = 12;
		motor[RightRearDrive] = 12;
	}
	wait1Msec(200);

	motor[LeftFrontDrive] = 0;
	motor[LeftRearDrive] = 0;
	motor[RightFrontDrive] = 0;
	motor[RightRearDrive] = 0;

	wait1Msec(200);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop
	clearLCDLine(0);
	clearLCDLine(1);
	stopTask(LCDControl);
	int y;
	int x;
	int threshhigh = 100;
	int threshlow = 20;

	while (true)
	{
		motor[Roller] = 0;
		motor[LeftLift] = 0;
		motor[RightLift] = 0;
		// make joystick move far enough before using values
		if(abs(vexRT[Ch3]) >= threshhigh)
		{
			y = vexRT[Ch3] * .8;
		}
		else if(abs(vexRT[Ch3]) <= threshlow)
		{
			y = 0;
		}
		else
		{
			y = vexRT[Ch3];
		}
		// make joystick move far enough before using values
		if(abs(vexRT[Ch1]) >= threshhigh)
		{
			x = vexRT[Ch1] * .8;
		}
		else if(abs(vexRT[Ch1]) <= threshlow)
		{
			x = 0;
		}

		else
		{
			x = vexRT[Ch1];
		}


		if(vexRT[Btn5U] == 1)
		{
			/*
			motor[LeftFrontDrive] = x/3 + y/2.5;
			motor[RightFrontDrive] = -x/3 + y/2.5;
			motor[LeftRearDrive] = x/3 + y/2.5;
			motor[RightRearDrive] = -x/3 + y/2.5;
			*/
			motor[LeftFrontDrive] = x + y;
			motor[RightFrontDrive] = -x + y;
			motor[LeftRearDrive] = x + y;
			motor[RightRearDrive] = -x + y;
		}
		else
		{
			/*
			motor[LeftFrontDrive] = x + y;
			motor[RightFrontDrive] = -x + y;
			motor[LeftRearDrive] = x + y;
			motor[RightRearDrive] = -x + y;
			*/
			motor[LeftFrontDrive] = x / 1.5 + y / 1.5;
			motor[RightFrontDrive] = -x / 1.5 + y / 1.5;
			motor[LeftRearDrive] = x / 1.5 + y / 1.5;
			motor[RightRearDrive] = -x / 1.5 + y / 1.5;
		}
		/*
		speed = 2600 - SensorValue[SwingPot];
		motor[LeftLift] = speed * 0.05;
		motor[RightLift] = speed * 0.05;
		motor[Roller] = -40;
		*/


		if(vexRT[Btn8U] == 1)
		{
			stopTask(mogoUp);
			startTask(mogoDown);
		}
		else if(vexRT[Btn8D] == 1)
		{
			stopTask(mogoDown);
			startTask(mogoUp);
		}

		if(vexRT[Btn6U] == 1)
		{
			autoStack();
		}
		if(vexRT[Btn7R] == 1)
		{
			driveReverseP(400);
		}
		if(vexRT[Btn7L] == 1)
		{
			turnLeft(500);
			wait1Msec(1000);
			turnRight(500);
			wait1Msec(1000);
			turnLeft(1050);
			wait1Msec(1000);
			turnRight(1050);
			wait1Msec(1000);

		}
		if(vexRT[Btn7D] == 1)
		{
			drivePID(200);
			wait1Msec(100);
			drivePID(400);
			wait1Msec(100);
			drivePID(400);
		}
		wait1Msec(20);
	}
	if(vexRT[Btn7U] == 1)
	{
		auton = 0;
		startTask(autonomous);
		stopTask(usercontrol);
	}
}
